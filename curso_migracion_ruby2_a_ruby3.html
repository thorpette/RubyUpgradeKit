<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Curso Completo: Migraci√≥n de Ruby 2 a Ruby 3</title>
    <style>
        @page {
            size: A4;
            margin: 2cm;
            @bottom-center {
                content: counter(page);
            }
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 210mm;
            margin: 0 auto;
            background: white;
        }
        .cover {
            text-align: center;
            padding: 100px 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin: -2cm -2cm 2cm -2cm;
            padding: 4cm 2cm;
        }
        .cover h1 {
            font-size: 3em;
            margin-bottom: 0.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .cover h2 {
            font-size: 1.5em;
            margin-bottom: 2em;
            opacity: 0.9;
        }
        .cover .author {
            font-size: 1.2em;
            margin-top: 2em;
        }
        .cover .date {
            font-size: 1em;
            margin-top: 1em;
            opacity: 0.8;
        }
        h1, h2, h3, h4, h5, h6 {
            color: #2c3e50;
            margin-top: 2em;
            margin-bottom: 0.5em;
        }
        h1 {
            font-size: 2.5em;
            border-bottom: 3px solid #3498db;
            padding-bottom: 0.3em;
        }
        h2 {
            font-size: 2em;
            border-bottom: 2px solid #3498db;
            padding-bottom: 0.3em;
        }
        h3 {
            font-size: 1.5em;
            color: #34495e;
        }
        .toc {
            background: #f8f9fa;
            padding: 2em;
            border-radius: 8px;
            margin: 2em 0;
            page-break-inside: avoid;
        }
        .toc h2 {
            margin-top: 0;
            border: none;
            color: #2c3e50;
        }
        .toc ul {
            list-style-type: none;
            padding: 0;
        }
        .toc li {
            margin: 0.5em 0;
            padding: 0.3em 0;
            border-bottom: 1px dotted #bdc3c7;
        }
        .toc a {
            text-decoration: none;
            color: #2980b9;
            font-weight: 500;
        }
        .code-block {
            background: #2d3748;
            color: #e2e8f0;
            padding: 1.5em;
            border-radius: 8px;
            font-family: 'Courier New', Consolas, monospace;
            font-size: 0.9em;
            overflow-x: auto;
            margin: 1em 0;
            border-left: 4px solid #4299e1;
        }
        .code-block .comment {
            color: #a0aec0;
        }
        .code-block .keyword {
            color: #f56565;
        }
        .code-block .string {
            color: #68d391;
        }
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1em;
            margin: 1.5em 0;
        }
        .comparison .ruby2 {
            background: #fed7d7;
            border: 2px solid #fc8181;
            border-radius: 8px;
            padding: 1em;
        }
        .comparison .ruby3 {
            background: #c6f6d5;
            border: 2px solid #68d391;
            border-radius: 8px;
            padding: 1em;
        }
        .comparison h4 {
            margin-top: 0;
            font-size: 1.1em;
        }
        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 1em;
            border-radius: 8px;
            margin: 1em 0;
            border-left: 4px solid #f39c12;
        }
        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 1em;
            border-radius: 8px;
            margin: 1em 0;
            border-left: 4px solid #27ae60;
        }
        .error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 1em;
            border-radius: 8px;
            margin: 1em 0;
            border-left: 4px solid #e74c3c;
        }
        .checklist {
            background: #f8f9fa;
            padding: 1.5em;
            border-radius: 8px;
            margin: 1.5em 0;
        }
        .checklist ul {
            list-style-type: none;
            padding: 0;
        }
        .checklist li {
            margin: 0.5em 0;
            padding: 0.5em;
            background: white;
            border-radius: 4px;
            border: 1px solid #e9ecef;
        }
        .checklist li:before {
            content: "‚òê ";
            font-weight: bold;
            color: #6c757d;
        }
        .checklist li.completed:before {
            content: "‚òë ";
            color: #27ae60;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1.5em 0;
        }
        th, td {
            border: 1px solid #dee2e6;
            padding: 0.75em;
            text-align: left;
        }
        th {
            background: #f8f9fa;
            font-weight: bold;
            color: #495057;
        }
        tr:nth-child(even) {
            background: #f8f9fa;
        }
        .page-break {
            page-break-before: always;
        }
        .no-break {
            page-break-inside: avoid;
        }
        .chapter-intro {
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
            padding: 2em;
            border-radius: 12px;
            margin: 2em 0;
            border-left: 5px solid #2196f3;
        }
        .exercise {
            background: #fff9c4;
            border: 2px solid #fdd835;
            border-radius: 8px;
            padding: 1.5em;
            margin: 2em 0;
        }
        .exercise h4 {
            margin-top: 0;
            color: #f57f17;
        }
        .progress-bar {
            width: 100%;
            height: 10px;
            background: #e9ecef;
            border-radius: 5px;
            margin: 1em 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #2196f3);
            border-radius: 5px;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="cover">
        <h1>üöÄ Curso Completo</h1>
        <h2>Migraci√≥n de Ruby 2 a Ruby 3</h2>
        <p style="font-size: 1.3em; margin: 2em 0;">Gu√≠a Pr√°ctica y Exhaustiva para Desarrolladores</p>
        <div class="author">
            <strong>Ruby Migrator Project</strong><br>
            Herramientas y Metodolog√≠as Avanzadas
        </div>
        <div class="date">
            Agosto 2025 - Versi√≥n 3.0<br>
            Actualizado para Ruby 3.3.8
        </div>
    </div>

    <div class="toc">
        <h2>üìö Tabla de Contenidos</h2>
        <ul>
            <li><a href="#introduccion">1. Introducci√≥n y Preparaci√≥n</a></li>
            <li><a href="#historia">2. Historia y Evoluci√≥n de Ruby 3</a></li>
            <li><a href="#preparacion">3. Preparaci√≥n del Entorno</a></li>
            <li><a href="#analisis">4. An√°lisis de Compatibilidad</a></li>
            <li><a href="#constantes">5. Constantes Removidas</a></li>
            <li><a href="#metodos">6. M√©todos Deprecados y Eliminados</a></li>
            <li><a href="#sintaxis">7. Cambios de Sintaxis</a></li>
            <li><a href="#argumentos">8. Argumentos de Palabras Clave</a></li>
            <li><a href="#rendimiento">9. Mejoras de Rendimiento</a></li>
            <li><a href="#herramientas">10. Herramientas de Migraci√≥n</a></li>
            <li><a href="#testing">11. Testing y Validaci√≥n</a></li>
            <li><a href="#despliegue">12. Despliegue y Producci√≥n</a></li>
            <li><a href="#casos-estudio">13. Casos de Estudio Reales</a></li>
            <li><a href="#mejores-practicas">14. Mejores Pr√°cticas</a></li>
            <li><a href="#recursos">15. Recursos y Referencias</a></li>
        </ul>
    </div>

    <div class="page-break"></div>

    <section id="introduccion">
        <h1>1. üéØ Introducci√≥n y Preparaci√≥n</h1>
        
        <div class="chapter-intro">
            <h3>Bienvenido al Curso Completo de Migraci√≥n Ruby 2 ‚Üí Ruby 3</h3>
            <p>Este curso te guiar√° paso a paso en el proceso de migraci√≥n de Ruby 2 a Ruby 3, cubriendo todos los aspectos t√©cnicos, mejores pr√°cticas y herramientas necesarias para una migraci√≥n exitosa.</p>
        </div>

        <h2>1.1 ¬øPor qu√© migrar a Ruby 3?</h2>
        
        <div class="success">
            <h4>‚úÖ Beneficios Clave de Ruby 3:</h4>
            <ul>
                <li><strong>Rendimiento:</strong> Hasta 3x m√°s r√°pido que Ruby 2.0</li>
                <li><strong>Concurrencia:</strong> Ractor para verdadero paralelismo</li>
                <li><strong>Typing:</strong> RBS para tipado est√°tico opcional</li>
                <li><strong>Compatibilidad:</strong> 99% compatible con Ruby 2.7</li>
                <li><strong>Seguridad:</strong> Mejoras en manejo de memoria</li>
            </ul>
        </div>

        <h2>1.2 Versiones y Cronolog√≠a</h2>
        
        <table>
            <tr>
                <th>Versi√≥n</th>
                <th>Fecha de Lanzamiento</th>
                <th>Soporte hasta</th>
                <th>Estado</th>
            </tr>
            <tr>
                <td>Ruby 2.0</td>
                <td>Febrero 2013</td>
                <td>Febrero 2016</td>
                <td>‚ùå Sin soporte</td>
            </tr>
            <tr>
                <td>Ruby 2.1</td>
                <td>Diciembre 2013</td>
                <td>Marzo 2017</td>
                <td>‚ùå Sin soporte</td>
            </tr>
            <tr>
                <td>Ruby 2.2</td>
                <td>Diciembre 2014</td>
                <td>Marzo 2018</td>
                <td>‚ùå Sin soporte</td>
            </tr>
            <tr>
                <td>Ruby 2.3</td>
                <td>Diciembre 2015</td>
                <td>Marzo 2019</td>
                <td>‚ùå Sin soporte</td>
            </tr>
            <tr>
                <td>Ruby 2.4</td>
                <td>Diciembre 2016</td>
                <td>Marzo 2020</td>
                <td>‚ùå Sin soporte</td>
            </tr>
            <tr>
                <td>Ruby 2.5</td>
                <td>Diciembre 2017</td>
                <td>Marzo 2021</td>
                <td>‚ùå Sin soporte</td>
            </tr>
            <tr>
                <td>Ruby 2.6</td>
                <td>Diciembre 2018</td>
                <td>Marzo 2022</td>
                <td>‚ùå Sin soporte</td>
            </tr>
            <tr>
                <td>Ruby 2.7</td>
                <td>Diciembre 2019</td>
                <td>Marzo 2023</td>
                <td>‚ùå Sin soporte</td>
            </tr>
            <tr>
                <td>Ruby 3.0</td>
                <td>Diciembre 2020</td>
                <td>Marzo 2024</td>
                <td>‚ùå Sin soporte</td>
            </tr>
            <tr>
                <td>Ruby 3.1</td>
                <td>Diciembre 2021</td>
                <td>Marzo 2025</td>
                <td>üî∂ Mantenimiento</td>
            </tr>
            <tr>
                <td>Ruby 3.2</td>
                <td>Diciembre 2022</td>
                <td>Marzo 2026</td>
                <td>‚úÖ Soporte completo</td>
            </tr>
            <tr>
                <td>Ruby 3.3</td>
                <td>Diciembre 2023</td>
                <td>Marzo 2027</td>
                <td>‚úÖ Soporte completo</td>
            </tr>
        </table>

        <h2>1.3 Preparaci√≥n del Proyecto</h2>

        <div class="checklist">
            <h4>üìã Lista de Verificaci√≥n Pre-Migraci√≥n:</h4>
            <ul>
                <li class="completed">Backup completo del c√≥digo fuente</li>
                <li class="completed">Documentar versiones actuales de gemas</li>
                <li>Crear rama espec√≠fica para migraci√≥n</li>
                <li>Configurar entorno de testing robusto</li>
                <li>Identificar dependencias cr√≠ticas</li>
                <li>Planificar rollback strategy</li>
                <li>Comunicar timeline al equipo</li>
            </ul>
        </div>

        <div class="exercise">
            <h4>üí° Ejercicio 1: Evaluaci√≥n Inicial</h4>
            <p><strong>Objetivo:</strong> Evaluar el estado actual de tu proyecto Ruby.</p>
            
            <div class="code-block">
# Ejecutar en terminal para obtener informaci√≥n del proyecto
ruby --version
bundle --version
gem list --local
git log --oneline -10
find . -name "*.rb" | wc -l
grep -r "Ruby" Gemfile*
            </div>
            
            <p><strong>Resultado esperado:</strong> Un reporte detallado del estado actual de tu aplicaci√≥n Ruby.</p>
        </div>
    </section>

    <div class="page-break"></div>

    <section id="historia">
        <h1>2. üìä Historia y Evoluci√≥n de Ruby 3</h1>
        
        <div class="chapter-intro">
            <h3>Ruby 3x3: La Visi√≥n Cumplida</h3>
            <p>Ruby 3 representa la culminaci√≥n de a√±os de desarrollo enfocado en el rendimiento, la concurrencia y la compatibilidad. La famosa promesa "Ruby 3x3" buscaba hacer Ruby 3 veces m√°s r√°pido que Ruby 2.0.</p>
        </div>

        <h2>2.1 Hitos Principales</h2>
        
        <table>
            <tr>
                <th>Caracter√≠stica</th>
                <th>Versi√≥n Introducida</th>
                <th>Impacto</th>
                <th>Estado en Ruby 3</th>
            </tr>
            <tr>
                <td>MJIT (JIT Compiler)</td>
                <td>Ruby 2.6</td>
                <td>Rendimiento</td>
                <td>‚úÖ Mejorado significativamente</td>
            </tr>
            <tr>
                <td>Ractor</td>
                <td>Ruby 3.0</td>
                <td>Concurrencia</td>
                <td>‚úÖ Paralelismo real</td>
            </tr>
            <tr>
                <td>Fiber Scheduler</td>
                <td>Ruby 3.0</td>
                <td>Async/IO</td>
                <td>‚úÖ I/O no bloqueante</td>
            </tr>
            <tr>
                <td>RBS (Type Signatures)</td>
                <td>Ruby 3.0</td>
                <td>Tipos</td>
                <td>‚úÖ Tipado est√°tico opcional</td>
            </tr>
            <tr>
                <td>TypeProf</td>
                <td>Ruby 3.0</td>
                <td>An√°lisis</td>
                <td>‚úÖ Inferencia de tipos</td>
            </tr>
        </table>

        <h2>2.2 Cambios Disruptivos (Breaking Changes)</h2>

        <div class="warning">
            <h4>‚ö†Ô∏è Cambios que Rompen Compatibilidad:</h4>
            <ul>
                <li><strong>Argumentos posicionales y por palabra clave separados</strong></li>
                <li><strong>Eliminaci√≥n de constantes: Fixnum, Bignum, NIL, TRUE, FALSE</strong></li>
                <li><strong>Remoci√≥n de m√©todos taint/untaint</strong></li>
                <li><strong>Cambios en Proc y lambda</strong></li>
                <li><strong>Modificaci√≥n en el comportamiento de $1, $2, etc.</strong></li>
            </ul>
        </div>

        <h2>2.3 Benchmark de Rendimiento</h2>

        <div class="code-block">
# Ejemplo de mejora de rendimiento
require 'benchmark'

def fibonacci(n)
  return n if n <= 1
  fibonacci(n-1) + fibonacci(n-2)
end

# Ruby 2.7 vs Ruby 3.3 - Fibonacci(35)
# Ruby 2.7: ~4.2 segundos
# Ruby 3.3: ~1.4 segundos (3x m√°s r√°pido)

Benchmark.bm do |x|
  x.report("Fibonacci(35):") { fibonacci(35) }
end
        </div>

        <div class="success">
            <h4>üöÄ Mejoras de Rendimiento Documentadas:</h4>
            <ul>
                <li><strong>Operaciones aritm√©ticas:</strong> 2-3x m√°s r√°pidas</li>
                <li><strong>Llamadas a m√©todos:</strong> 1.5-2x m√°s r√°pidas</li>
                <li><strong>Asignaci√≥n de objetos:</strong> 1.3x m√°s eficiente</li>
                <li><strong>Garbage Collection:</strong> Latencia reducida 40%</li>
                <li><strong>I/O operations:</strong> Hasta 10x en casos async</li>
            </ul>
        </div>
    </section>

    <div class="page-break"></div>

    <section id="preparacion">
        <h1>3. üîß Preparaci√≥n del Entorno</h1>
        
        <div class="chapter-intro">
            <h3>Configuraci√≥n Profesional para Migraci√≥n</h3>
            <p>Una migraci√≥n exitosa requiere un entorno bien preparado con las herramientas correctas y procesos establecidos.</p>
        </div>

        <h2>3.1 Instalaci√≥n de Ruby 3</h2>

        <h3>Usando rbenv (Recomendado)</h3>
        <div class="code-block">
# Actualizar rbenv
cd ~/.rbenv && git pull

# Listar versiones disponibles
rbenv install --list | grep 3\.

# Instalar Ruby 3.3.8 (√∫ltima estable)
rbenv install 3.3.8

# Configurar como global o local
rbenv global 3.3.8
# o para proyecto espec√≠fico:
rbenv local 3.3.8

# Verificar instalaci√≥n
ruby --version
# ruby 3.3.8 (2024-04-09 revision 12345) [x86_64-linux]
        </div>

        <h3>Usando RVM</h3>
        <div class="code-block">
# Actualizar RVM
rvm get stable

# Instalar Ruby 3.3.8
rvm install ruby-3.3.8

# Usar la nueva versi√≥n
rvm use ruby-3.3.8 --default

# Crear gemset espec√≠fico para migraci√≥n
rvm gemset create migration
rvm use ruby-3.3.8@migration
        </div>

        <h3>Usando Docker (Para Testing)</h3>
        <div class="code-block">
# Dockerfile para testing
FROM ruby:3.3.8-alpine

WORKDIR /app
COPY Gemfile* ./
RUN bundle install
COPY . .

# Comando para testing
ENTRYPOINT ["bundle", "exec"]
        </div>

        <h2>3.2 Configuraci√≥n de Bundle</h2>

        <div class="code-block">
# Gemfile actualizado
source 'https://rubygems.org'

ruby '3.3.8'  # Especificar versi√≥n requerida

# Gemas core que pueden necesitar actualizaci√≥n
gem 'webrick', '~> 1.8'    # Requerido para servidor web
gem 'psych', '~> 5.0'      # YAML parser
gem 'fiddle', '~> 1.1'     # FFI wrapper
gem 'stringio', '~> 3.0'   # String I/O operations

# Resto de tu aplicaci√≥n...
        </div>

        <div class="code-block">
# Configurar bundle para desarrollo
bundle config set --local path 'vendor/bundle'
bundle config set --local jobs 4
bundle config set --local retry 3

# Instalar dependencias
bundle install

# Verificar compatibilidad
bundle exec ruby -c Gemfile
bundle doctor
        </div>

        <h2>3.3 Herramientas de An√°lisis</h2>

        <div class="code-block">
# Instalar herramientas de migraci√≥n
gem install ruby_migrator
gem install rubocop-migration
gem install bundler-audit

# Herramientas espec√≠ficas para Ruby 3
gem install rbs
gem install typeprof
gem install steep
        </div>

        <h2>3.4 Configuraci√≥n de Testing</h2>

        <div class="code-block">
# spec/spec_helper.rb o test/test_helper.rb

# Configurar warnings para detectar deprecations
if RUBY_VERSION >= "3.0"
  Warning.process(__FILE__) do |warning|
    # Log warnings para an√°lisis posterior
    File.open("migration_warnings.log", "a") do |f|
      f.puts "[#{Time.now}] #{warning}"
    end
    
    # Mostrar warnings en desarrollo
    warn warning if Rails.env.development?
  end
end

# Configurar variable de entorno para testing
ENV['RUBY_VERSION'] = RUBY_VERSION
ENV['MIGRATION_MODE'] = 'true'
        </div>

        <div class="exercise">
            <h4>üí° Ejercicio 2: Configuraci√≥n de Entorno</h4>
            <p><strong>Objetivo:</strong> Configurar un entorno completo para migraci√≥n.</p>
            
            <div class="code-block">
#!/bin/bash
# setup_migration_env.sh

echo "üöÄ Configurando entorno de migraci√≥n Ruby 2‚Üí3"

# 1. Verificar versiones actuales
echo "Versiones actuales:"
ruby --version
bundle --version
gem --version

# 2. Crear backup del Gemfile
cp Gemfile Gemfile.ruby2.backup
cp Gemfile.lock Gemfile.lock.ruby2.backup

# 3. Crear rama de migraci√≥n
git checkout -b ruby3-migration

# 4. Configurar bundle para nueva versi√≥n
bundle config set --local path 'vendor/bundle'
bundle config set --local jobs $(nproc)

echo "‚úÖ Entorno preparado para migraci√≥n"
            </div>
            
            <p><strong>Resultado esperado:</strong> Entorno completamente configurado con backups y herramientas instaladas.</p>
        </div>
    </section>

    <div class="page-break"></div>

    <section id="analisis">
        <h1>4. üîç An√°lisis de Compatibilidad</h1>
        
        <div class="chapter-intro">
            <h3>Identificaci√≥n Sistem√°tica de Problemas</h3>
            <p>Antes de realizar cambios, es crucial identificar todos los puntos de incompatibilidad en tu c√≥digo base.</p>
        </div>

        <h2>4.1 An√°lisis Autom√°tico con Ruby Migrator</h2>

        <div class="code-block">
# Instalar Ruby Migrator
gem install ruby_migrator

# An√°lisis b√°sico (solo reporte)
ruby_migrator --path mi_proyecto --report-only

# An√°lisis detallado con formato JSON
ruby_migrator --path mi_proyecto --format json --verbose > reporte.json

# An√°lisis espec√≠fico de directorio
ruby_migrator --path app/models --report-only --verbose
        </div>

        <h3>Ejemplo de Reporte de An√°lisis</h3>
        <div class="code-block">
üîç Ruby 2‚Üí3 Migration Analysis Report
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìä Summary:
  ‚Ä¢ Files analyzed: 45
  ‚Ä¢ Errors found: 12
  ‚Ä¢ Warnings: 18
  ‚Ä¢ Info items: 6
  ‚Ä¢ Total issues: 36

üö® Critical Issues (Errors):
  ‚îú‚îÄ‚îÄ app/models/user.rb:15 - Removed constant 'Fixnum'
  ‚îú‚îÄ‚îÄ app/helpers/format.rb:23 - Deprecated method 'taint'
  ‚îú‚îÄ‚îÄ config/application.rb:8 - Positional/keyword argument issue
  ‚îî‚îÄ‚îÄ lib/utils.rb:45 - Invalid lambda syntax

‚ö†Ô∏è  Warnings:
  ‚îú‚îÄ‚îÄ app/views/layouts/app.html.erb:12 - Hash syntax (upgrade recommended)
  ‚îú‚îÄ‚îÄ spec/models/user_spec.rb:34 - Global variable usage ($1, $2)
  ‚îî‚îÄ‚îÄ Gemfile:23 - Gem version may be incompatible

‚ÑπÔ∏è  Informational:
  ‚îú‚îÄ‚îÄ README.md - Update Ruby version references
  ‚îî‚îÄ‚îÄ .ruby-version - Update to 3.3.8
        </div>

        <h2>4.2 An√°lisis Manual con Grep</h2>

        <div class="code-block">
#!/bin/bash
# manual_analysis.sh - B√∫squeda manual de patrones problem√°ticos

echo "üîç An√°lisis manual de compatibilidad Ruby 3"

# Buscar constantes removidas
echo "‚ñ∂ Constantes removidas:"
grep -r "Fixnum\|Bignum\|NIL\|TRUE\|FALSE" app/ lib/ --include="*.rb"

# Buscar m√©todos deprecados
echo "‚ñ∂ M√©todos deprecados:"
grep -r "\.taint\|\.untaint\|\.trust\|\.untrust" app/ lib/ --include="*.rb"

# Buscar sintaxis de hash antigua
echo "‚ñ∂ Sintaxis hash antigua:"
grep -r ":\w\+\s*=>" app/ lib/ --include="*.rb"

# Buscar variables globales problem√°ticas
echo "‚ñ∂ Variables globales:"
grep -r '\$[1-9][0-9]*' app/ lib/ --include="*.rb"

# Buscar usage de lambda/proc potencialmente problem√°tico
echo "‚ñ∂ Lambda/Proc usage:"
grep -r "lambda\|proc\|Proc\.new" app/ lib/ --include="*.rb"
        </div>

        <h2>4.3 An√°lisis de Dependencias</h2>

        <div class="code-block">
# bundle_analyzer.rb - An√°lisis de gemas
require 'bundler'

puts "üì¶ An√°lisis de Gemas para Ruby 3"
puts "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

Bundler.load.specs.each do |spec|
  puts "#{spec.name} (#{spec.version})"
  
  # Verificar soporte Ruby 3
  if spec.required_ruby_version
    supports_ruby3 = spec.required_ruby_version.satisfied_by?(Gem::Version.new('3.0'))
    status = supports_ruby3 ? "‚úÖ" : "‚ùå"
    puts "  Ruby 3 support: #{status}"
  end
  
  # Verificar √∫ltima actualizaci√≥n
  age = (Date.today - spec.date.to_date).to_i
  if age > 730  # M√°s de 2 a√±os
    puts "  ‚ö†Ô∏è  Gema antigua (#{age} d√≠as sin actualizar)"
  end
  
  puts
end
        </div>

        <h2>4.4 Testing de Compatibilidad</h2>

        <div class="code-block">
# compatibility_test.rb
require 'test/unit'

class CompatibilityTest < Test::Unit::TestCase
  def test_ruby_version
    assert RUBY_VERSION >= "3.0", "Ruby 3.0+ requerido"
  end
  
  def test_removed_constants
    # Verificar que constantes removidas no se usen
    refute defined?(Fixnum), "Fixnum removido en Ruby 3"
    refute defined?(Bignum), "Bignum removido en Ruby 3"
  end
  
  def test_integer_unification
    # Verificar unificaci√≥n Integer
    assert_equal Integer, 1.class
    assert_equal Integer, (2**100).class
  end
  
  def test_keyword_arguments
    # Verificar separaci√≥n de argumentos
    def test_method(pos, key: nil)
      [pos, key]
    end
    
    # Esto debe funcionar
    assert_equal [1, 2], test_method(1, key: 2)
    
    # Esto puede generar warning en Ruby 3
    # test_method(1, {key: 2})  # Deprecated
  end
  
  def test_hash_syntax
    # Verificar nueva sintaxis hash
    old_style = {:key => 'value'}
    new_style = {key: 'value'}
    
    assert_equal old_style, new_style
  end
end
        </div>

        <div class="exercise">
            <h4>üí° Ejercicio 3: An√°lisis Completo</h4>
            <p><strong>Objetivo:</strong> Realizar un an√°lisis exhaustivo de tu aplicaci√≥n.</p>
            
            <div class="code-block">
# analysis_script.rb
#!/usr/bin/env ruby

class MigrationAnalyzer
  def initialize(project_path)
    @project_path = project_path
    @issues = []
  end
  
  def analyze
    puts "üöÄ Iniciando an√°lisis de migraci√≥n Ruby 2‚Üí3"
    puts "Proyecto: #{@project_path}"
    puts "‚ïê" * 50
    
    analyze_ruby_files
    analyze_gemfile
    analyze_configuration
    generate_report
  end
  
  private
  
  def analyze_ruby_files
    Dir.glob("#{@project_path}/**/*.rb").each do |file|
      content = File.read(file)
      
      # An√°lizar patrones problem√°ticos
      check_removed_constants(file, content)
      check_deprecated_methods(file, content)
      check_hash_syntax(file, content)
      check_global_variables(file, content)
    end
  end
  
  def check_removed_constants(file, content)
    %w[Fixnum Bignum NIL TRUE FALSE].each do |const|
      if content.match(/\b#{const}\b/)
        @issues << {
          file: file,
          type: :error,
          message: "Constante removida: #{const}",
          line: content.lines.find_index { |l| l.include?(const) } + 1
        }
      end
    end
  end
  
  def check_deprecated_methods(file, content)
    %w[taint untaint trust untrust].each do |method|
      if content.match(/\.#{method}\b/)
        @issues << {
          file: file,
          type: :error,
          message: "M√©todo removido: #{method}",
          line: content.lines.find_index { |l| l.include?(".#{method}") } + 1
        }
      end
    end
  end
  
  def check_hash_syntax(file, content)
    if content.match(/:(\w+)\s*=>/)
      @issues << {
        file: file,
        type: :warning,
        message: "Sintaxis hash antigua detectada",
        suggestion: "Considerar migrar a nueva sintaxis {key: value}"
      }
    end
  end
  
  def check_global_variables(file, content)
    if content.match(/\$[1-9]/)
      @issues << {
        file: file,
        type: :info,
        message: "Uso de variables globales $1, $2, etc.",
        suggestion: "Verificar comportamiento en Ruby 3"
      }
    end
  end
  
  def analyze_gemfile
    # Implementar an√°lisis de Gemfile
  end
  
  def analyze_configuration
    # Implementar an√°lisis de configuraci√≥n
  end
  
  def generate_report
    puts "\nüìä REPORTE DE AN√ÅLISIS"
    puts "‚ïê" * 50
    
    errors = @issues.select { |i| i[:type] == :error }
    warnings = @issues.select { |i| i[:type] == :warning }
    infos = @issues.select { |i| i[:type] == :info }
    
    puts "üö® Errores: #{errors.count}"
    puts "‚ö†Ô∏è  Advertencias: #{warnings.count}"
    puts "‚ÑπÔ∏è  Informaci√≥n: #{infos.count}"
    puts "üìà Total: #{@issues.count}"
    
    if errors.any?
      puts "\nüö® ERRORES CR√çTICOS:"
      errors.each do |issue|
        puts "  üìÅ #{issue[:file]}"
        puts "     #{issue[:message]}"
        puts "     L√≠nea: #{issue[:line]}" if issue[:line]
        puts
      end
    end
  end
end

# Usar el analizador
if ARGV[0]
  analyzer = MigrationAnalyzer.new(ARGV[0])
  analyzer.analyze
else
  puts "Uso: ruby analysis_script.rb /ruta/al/proyecto"
end
            </div>
            
            <p><strong>Resultado esperado:</strong> Un reporte detallado de todos los problemas de compatibilidad encontrados.</p>
        </div>
    </section>

    <div class="page-break"></div>

    <section id="constantes">
        <h1>5. üîß Constantes Removidas</h1>
        
        <div class="chapter-intro">
            <h3>Unificaci√≥n del Sistema Num√©rico</h3>
            <p>Ruby 3 elimina varias constantes que fueron unificadas en versiones anteriores, siendo la m√°s importante la unificaci√≥n de Fixnum y Bignum en Integer.</p>
        </div>

        <h2>5.1 Fixnum y Bignum ‚Üí Integer</h2>

        <div class="comparison">
            <div class="ruby2">
                <h4>‚ùå Ruby 2 (Problem√°tico)</h4>
                <div class="code-block">
# Verificaci√≥n de tipo antigua
if number.class == Fixnum
  puts "N√∫mero peque√±o"
elsif number.class == Bignum  
  puts "N√∫mero grande"
end

# Case statement problem√°tico
case number.class
when Fixnum
  handle_small_number(number)
when Bignum
  handle_big_number(number)
end

# Constantes en comparaciones
def is_integer?(obj)
  obj.class == Fixnum || obj.class == Bignum
end
                </div>
            </div>
            <div class="ruby3">
                <h4>‚úÖ Ruby 3 (Correcto)</h4>
                <div class="code-block">
# Verificaci√≥n unificada
if number.class == Integer
  puts "N√∫mero entero"
end

# Mejor: usar is_a?
if number.is_a?(Integer)
  puts "Es un entero"
end

# Case statement corregido
case number.class
when Integer
  handle_integer(number)
end

# Funci√≥n corregida
def is_integer?(obj)
  obj.is_a?(Integer)
end

# Alternativa m√°s idiom√°tica
def is_integer?(obj)
  obj.kind_of?(Integer)
end
                </div>
            </div>
        </div>

        <h2>5.2 Constantes Booleanas: NIL, TRUE, FALSE</h2>

        <div class="comparison">
            <div class="ruby2">
                <h4>‚ùå Ruby 2 (Problem√°tico)</h4>
                <div class="code-block">
# Uso de constantes removidas
value = NIL
result = TRUE
error_state = FALSE

# En comparaciones
if response == NIL
  handle_nil_response
end

# En case statements
case status
when TRUE
  process_success
when FALSE
  process_failure  
when NIL
  process_unknown
end

# Asignaciones directas
DEFAULT_VALUE = NIL
SUCCESS_STATUS = TRUE
FAILURE_STATUS = FALSE
                </div>
            </div>
            <div class="ruby3">
                <h4>‚úÖ Ruby 3 (Correcto)</h4>
                <div class="code-block">
# Usar literales directos
value = nil
result = true
error_state = false

# Comparaciones corregidas
if response.nil?
  handle_nil_response
end

# Case statements corregidos
case status
when true
  process_success
when false
  process_failure
when nil
  process_unknown
end

# Constantes corregidas
DEFAULT_VALUE = nil
SUCCESS_STATUS = true
FAILURE_STATUS = false

# Mejor pr√°ctica: usar s√≠mbolos
DEFAULT_VALUE = :none
SUCCESS_STATUS = :success
FAILURE_STATUS = :failure
                </div>
            </div>
        </div>

        <h2>5.3 Herramientas de Migraci√≥n Autom√°tica</h2>

        <div class="code-block">
#!/usr/bin/env ruby
# constant_migrator.rb - Migrador autom√°tico de constantes

class ConstantMigrator
  CONSTANT_MAPPINGS = {
    'Fixnum' => 'Integer',
    'Bignum' => 'Integer', 
    'NIL' => 'nil',
    'TRUE' => 'true',
    'FALSE' => 'false'
  }.freeze
  
  def initialize(file_path)
    @file_path = file_path
    @content = File.read(file_path)
    @changes_made = []
  end
  
  def migrate!
    backup_file
    
    CONSTANT_MAPPINGS.each do |old_const, new_const|
      migrate_constant(old_const, new_const)
    end
    
    write_changes if @changes_made.any?
    report_changes
  end
  
  private
  
  def migrate_constant(old_const, new_const)
    pattern = /\b#{Regexp.escape(old_const)}\b/
    matches = @content.scan(pattern)
    
    if matches.any?
      @content.gsub!(pattern, new_const)
      @changes_made << {
        old: old_const,
        new: new_const,
        count: matches.size
      }
    end
  end
  
  def backup_file
    backup_name = "#{@file_path}.ruby2.backup"
    File.write(backup_name, File.read(@file_path))
    puts "‚úÖ Backup creado: #{backup_name}"
  end
  
  def write_changes
    File.write(@file_path, @content)
    puts "‚úÖ Archivo actualizado: #{@file_path}"
  end
  
  def report_changes
    if @changes_made.any?
      puts "üìä Cambios realizados:"
      @changes_made.each do |change|
        puts "  ‚Ä¢ #{change[:old]} ‚Üí #{change[:new]} (#{change[:count]} ocurrencias)"
      end
    else
      puts "‚ÑπÔ∏è  No se encontraron constantes a migrar"
    end
  end
end

# Uso del migrador
if ARGV.empty?
  puts "Uso: ruby constant_migrator.rb archivo.rb"
  exit 1
end

ARGV.each do |file|
  if File.exist?(file)
    puts "üîÑ Migrando: #{file}"
    migrator = ConstantMigrator.new(file)
    migrator.migrate!
    puts
  else
    puts "‚ùå Archivo no encontrado: #{file}"
  end
end
        </div>

        <h2>5.4 Testing de Constantes</h2>

        <div class="code-block">
# test/test_constants.rb
require 'test/unit'

class ConstantMigrationTest < Test::Unit::TestCase
  def test_fixnum_bignum_removed
    # Verificar que las constantes no existen
    assert_raises(NameError) { Fixnum }
    assert_raises(NameError) { Bignum }
    
    puts "‚úÖ Fixnum y Bignum correctamente removidos"
  end
  
  def test_integer_unification
    small_number = 1
    big_number = 2**100
    
    # Ambos deben ser Integer
    assert_equal Integer, small_number.class
    assert_equal Integer, big_number.class
    
    # Verificar que is_a? funciona
    assert small_number.is_a?(Integer)
    assert big_number.is_a?(Integer)
    
    puts "‚úÖ Unificaci√≥n Integer funcionando"
  end
  
  def test_boolean_constants_removed
    # Verificar que las constantes booleanas no existen
    assert_raises(NameError) { NIL }
    assert_raises(NameError) { TRUE }
    assert_raises(NameError) { FALSE }
    
    puts "‚úÖ Constantes booleanas correctamente removidas"
  end
  
  def test_literal_values_work
    # Verificar que los literales funcionan
    assert_nil nil
    assert_equal true, true
    assert_equal false, false
    
    # Verificar comparaciones
    assert nil.nil?
    assert_not true.nil?
    assert_not false.nil?
    
    puts "‚úÖ Literales booleanos funcionando"
  end
end

# Ejecutar tests
if __FILE__ == $0
  puts "üß™ Ejecutando tests de constantes..."
  # Los tests se ejecutar√°n autom√°ticamente
end
        </div>

        <div class="exercise">
            <h4>üí° Ejercicio 4: Migraci√≥n de Constantes</h4>
            <p><strong>Objetivo:</strong> Migrar todas las constantes removidas en un proyecto real.</p>
            
            <div class="code-block">
# migration_exercise.rb
class ConstantMigrationExercise
  def self.run
    puts "üéØ Ejercicio: Migraci√≥n de Constantes"
    puts "=" * 40
    
    # Crear archivos de ejemplo con problemas
    create_sample_files
    
    # Ejecutar migraci√≥n
    migrate_all_files
    
    # Verificar resultados  
    verify_migration
    
    puts "‚úÖ Ejercicio completado"
  end
  
  def self.create_sample_files
    sample_code = <<~RUBY
      class ExampleClass
        def check_number_type(num)
          case num.class
          when Fixnum
            "Small number: \#{num}"
          when Bignum
            "Big number: \#{num}"
          else
            "Not a number"
          end
        end
        
        def process_value(val)
          return NIL if val.nil?
          return TRUE if val == 1
          return FALSE if val == 0
          val
        end
      end
    RUBY
    
    File.write('example_class.rb', sample_code)
    puts "üìù Archivo de ejemplo creado: example_class.rb"
  end
  
  def self.migrate_all_files
    Dir.glob('*.rb').each do |file|
      next if file == __FILE__
      
      migrator = ConstantMigrator.new(file)
      migrator.migrate!
    end
  end
  
  def self.verify_migration
    puts "\nüîç Verificando migraci√≥n..."
    
    Dir.glob('*.rb').each do |file|
      next if file == __FILE__ || file.include?('.backup')
      
      content = File.read(file)
      
      # Verificar que no quedan constantes problem√°ticas
      problems = []
      %w[Fixnum Bignum NIL TRUE FALSE].each do |const|
        problems << const if content.include?(const)
      end
      
      if problems.empty?
        puts "‚úÖ #{file}: Sin problemas"
      else
        puts "‚ùå #{file}: Constantes pendientes: #{problems.join(', ')}"
      end
    end
  end
end

# Ejecutar ejercicio
ConstantMigrationExercise.run if __FILE__ == $0
            </div>
            
            <p><strong>Resultado esperado:</strong> Todos los archivos migrados sin constantes problem√°ticas y con backups creados.</p>
        </div>
    </section>

    <div class="page-break"></div>

    <section id="metodos">
        <h1>6. üö´ M√©todos Deprecados y Eliminados</h1>
        
        <div class="chapter-intro">
            <h3>Limpieza del API de Ruby</h3>
            <p>Ruby 3 elimina varios m√©todos que fueron deprecados en versiones anteriores, principalmente relacionados con el sistema de "taint" y "trust".</p>
        </div>

        <h2>6.1 Sistema Taint/Trust Eliminado</h2>

        <div class="warning">
            <h4>‚ö†Ô∏è M√©todos Completamente Removidos en Ruby 3:</h4>
            <ul>
                <li><code>Object#taint</code></li>
                <li><code>Object#untaint</code></li>
                <li><code>Object#tainted?</code></li>
                <li><code>Object#trust</code></li>
                <li><code>Object#untrust</code></li>
                <li><code>Object#untrusted?</code></li>
            </ul>
        </div>

        <div class="comparison">
            <div class="ruby2">
                <h4>‚ùå Ruby 2 (Removido)</h4>
                <div class="code-block">
# Sistema taint para seguridad
user_input = gets.chomp
user_input.taint  # Marcar como no confiable

# Verificar estado taint
if user_input.tainted?
  sanitize_input(user_input)
end

# Remover taint despu√©s de sanitizar
clean_input = sanitize_input(user_input)
clean_input.untaint

# Sistema trust
data = external_source.fetch
data.untrust  # Marcar como no confiable

if data.untrusted?
  validate_data(data)
end

# Confiar en datos validados
validated_data.trust
                </div>
            </div>
            <div class="ruby3">
                <h4>‚úÖ Ruby 3 (Alternativas)</h4>
                <div class="code-block">
# Usar validaci√≥n expl√≠cita
user_input = gets.chomp

# Mantener estado de validaci√≥n manualmente
class SecureString
  attr_reader :value, :validated
  
  def initialize(value)
    @value = value
    @validated = false
  end
  
  def validate!
    # L√≥gica de validaci√≥n
    @value = sanitize(@value)
    @validated = true
    self
  end
  
  def safe_value
    raise SecurityError unless @validated
    @value
  end
end

# Uso del sistema personalizado
secure_input = SecureString.new(user_input)
secure_input.validate!
safe_data = secure_input.safe_value

# Alternativa con m√≥dulos
module SecurityMarker
  def mark_untrusted
    @untrusted = true
  end
  
  def mark_trusted  
    @untrusted = false
  end
  
  def trusted?
    !@untrusted
  end
end
                </div>
            </div>
        </div>

        <h2>6.2 Otros M√©todos Deprecados</h2>

        <table>
            <tr>
                <th>M√©todo Removido</th>
                <th>Clase</th>
                <th>Alternativa en Ruby 3</th>
                <th>Notas</th>
            </tr>
            <tr>
                <td><code>Dir.exists?</code></td>
                <td>Dir</td>
                <td><code>Dir.exist?</code></td>
                <td>Cambio de nombre</td>
            </tr>
            <tr>
                <td><code>File.exists?</code></td>
                <td>File</td>
                <td><code>File.exist?</code></td>
                <td>Cambio de nombre</td>
            </tr>
            <tr>
                <td><code>Integer#size</code></td>
                <td>Integer</td>
                <td>No hay reemplazo directo</td>
                <td>Poco usado</td>
            </tr>
            <tr>
                <td><code>Proc#==</code></td>
                <td>Proc</td>
                <td><code>Proc#equal?</code></td>
                <td>Cambio sem√°ntico</td>
            </tr>
        </table>

        <h2>6.3 Migraci√≥n Autom√°tica de M√©todos</h2>

        <div class="code-block">
#!/usr/bin/env ruby
# method_migrator.rb - Migrador de m√©todos deprecados

class MethodMigrator
  REMOVED_METHODS = [
    'taint', 'untaint', 'tainted?',
    'trust', 'untrust', 'untrusted?'
  ].freeze
  
  METHOD_REPLACEMENTS = {
    'File.exists?' => 'File.exist?',
    'Dir.exists?' => 'Dir.exist?'
  }.freeze
  
  def initialize(file_path)
    @file_path = file_path
    @content = File.read(file_path)
    @issues = []
  end
  
  def analyze_and_migrate!
    puts "üîç Analizando: #{@file_path}"
    
    find_removed_methods
    apply_replacements
    
    if @issues.any?
      create_backup
      generate_migration_report
      write_changes
    else
      puts "‚úÖ No se encontraron m√©todos a migrar"
    end
  end
  
  private
  
  def find_removed_methods
    REMOVED_METHODS.each do |method|
      pattern = /\.#{method}(\b|\()/
      @content.scan(pattern) do |match|
        line_number = @content[0..$~.begin(0)].count("\n") + 1
        @issues << {
          type: :removed_method,
          method: method,
          line: line_number,
          action: :manual_review_required
        }
      end
    end
  end
  
  def apply_replacements
    METHOD_REPLACEMENTS.each do |old_method, new_method|
      if @content.include?(old_method)
        @content.gsub!(old_method, new_method)
        @issues << {
          type: :method_replacement,
          old: old_method,
          new: new_method,
          action: :automatically_replaced
        }
      end
    end
  end
  
  def create_backup
    backup_path = "#{@file_path}.pre_method_migration.backup"
    File.write(backup_path, File.read(@file_path))
    puts "üíæ Backup creado: #{backup_path}"
  end
  
  def generate_migration_report
    puts "\nüìä REPORTE DE MIGRACI√ìN DE M√âTODOS"
    puts "‚îÄ" * 50
    
    automatic_changes = @issues.select { |i| i[:action] == :automatically_replaced }
    manual_reviews = @issues.select { |i| i[:action] == :manual_review_required }
    
    if automatic_changes.any?
      puts "‚úÖ Cambios autom√°ticos aplicados:"
      automatic_changes.each do |change|
        puts "  ‚Ä¢ #{change[:old]} ‚Üí #{change[:new]}"
      end
      puts
    end
    
    if manual_reviews.any?
      puts "‚ö†Ô∏è  Revisi√≥n manual requerida:"
      manual_reviews.each do |issue|
        puts "  ‚Ä¢ L√≠nea #{issue[:line]}: M√©todo removido '#{issue[:method]}'"
        puts "    Acci√≥n: Implementar alternativa de seguridad"
      end
      puts
      
      generate_security_suggestions(manual_reviews)
    end
  end
  
  def generate_security_suggestions(manual_reviews)
    puts "üí° SUGERENCIAS PARA M√âTODOS DE SEGURIDAD:"
    puts "‚îÄ" * 50
    
    security_methods = manual_reviews.select { |i| 
      %w[taint untaint tainted? trust untrust untrusted?].include?(i[:method])
    }
    
    if security_methods.any?
      puts <<~SUGGESTIONS
      
      Para reemplazar el sistema taint/trust, considera:
      
      1. Validaci√≥n Expl√≠cita:
         ```ruby
         class SecureData
           def initialize(value)
             @value = value
             @validated = false
           end
           
           def validate!
             # Tu l√≥gica de validaci√≥n
             @validated = true
           end
           
           def safe_value
             raise SecurityError unless @validated
             @value
           end
         end
         ```
      
      2. Usar bibliotecas de sanitizaci√≥n:
         - Loofah para HTML
         - Addressable para URLs
         - ActiveRecord para SQL
      
      3. Patrones de validaci√≥n:
         - Whitelisting en lugar de blacklisting
         - Validaci√≥n en la entrada y salida
         - Uso de tipos seguros
      
      SUGGESTIONS
    end
  end
  
  def write_changes
    File.write(@file_path, @content)
    puts "‚úÖ Cambios aplicados a: #{@file_path}"
  end
end

# Script principal
if ARGV.empty?
  puts "Uso: ruby method_migrator.rb archivo.rb [archivo2.rb ...]"
  puts "O para migrar todo un directorio:"
  puts "find . -name '*.rb' -exec ruby method_migrator.rb {} +"
  exit 1
end

ARGV.each do |file_path|
  if File.exist?(file_path) && file_path.end_with?('.rb')
    migrator = MethodMigrator.new(file_path)
    migrator.analyze_and_migrate!
    puts
  else
    puts "‚ö†Ô∏è  Saltando: #{file_path} (no es archivo Ruby v√°lido)"
  end
end
        </div>

        <h2>6.4 Alternativas de Seguridad</h2>

        <div class="code-block">
# security_alternatives.rb - Alternativas al sistema taint/trust

# 1. Sistema de validaci√≥n basado en clases
class ValidatedString
  attr_reader :raw_value
  
  def initialize(value)
    @raw_value = value.to_s
    @validations = []
    @sanitizers = []
  end
  
  def add_validation(&block)
    @validations << block
    self
  end
  
  def add_sanitizer(&block)
    @sanitizers << block
    self
  end
  
  def validate!
    @validations.each do |validation|
      raise SecurityError, "Validation failed" unless validation.call(@raw_value)
    end
    self
  end
  
  def sanitize!
    @sanitizers.each do |sanitizer|
      @raw_value = sanitizer.call(@raw_value)
    end
    self
  end
  
  def safe_value
    validate!
    sanitize!
    @raw_value
  end
end

# 2. M√≥dulo para marcar objetos
module SecurityMarker
  def self.included(base)
    base.extend(ClassMethods)
  end
  
  module ClassMethods
    def secure_attr_accessor(*attrs)
      attrs.each do |attr|
        define_method(attr) do
          instance_variable_get("@#{attr}")
        end
        
        define_method("#{attr}=") do |value|
          if value.is_a?(String) && !value.frozen?
            warn "Warning: Setting mutable string to secure attribute"
          end
          instance_variable_set("@#{attr}", value)
        end
        
        define_method("#{attr}_validated?") do
          instance_variable_get("@#{attr}_validated") || false
        end
        
        define_method("validate_#{attr}!") do |&block|
          value = instance_variable_get("@#{attr}")
          if block_given?
            raise SecurityError unless block.call(value)
          end
          instance_variable_set("@#{attr}_validated", true)
        end
      end
    end
  end
end

# 3. Factory para objetos seguros
class SecureObjectFactory
  def self.create_secure_string(value)
    ValidatedString.new(value)
      .add_validation { |v| v.length < 1000 }
      .add_validation { |v| !v.include?('<script') }
      .add_sanitizer { |v| v.gsub(/[<>]/, '') }
  end
  
  def self.create_secure_email(email)
    ValidatedString.new(email)
      .add_validation { |e| e.match?(/\A[\w+\-.]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+\z/i) }
      .add_sanitizer { |e| e.strip.downcase }
  end
  
  def self.create_secure_url(url)
    require 'uri'
    ValidatedString.new(url)
      .add_validation { |u| URI.parse(u) rescue false }
      .add_validation { |u| !u.match?(/javascript:|data:/i) }
      .add_sanitizer { |u| URI.parse(u).to_s }
  end
end

# Ejemplos de uso
puts "üîí Ejemplos de Sistema de Seguridad Alternativo"
puts "‚îÄ" * 50

# Ejemplo 1: String validado
user_input = "Hello <script>alert('xss')</script> World"
secure_string = SecureObjectFactory.create_secure_string(user_input)

begin
  safe_output = secure_string.safe_value
  puts "‚úÖ String seguro: '#{safe_output}'"
rescue SecurityError => e
  puts "‚ùå Error de seguridad: #{e.message}"
end

# Ejemplo 2: Email validado
email_input = "USER@EXAMPLE.COM  "
secure_email = SecureObjectFactory.create_secure_email(email_input)
safe_email = secure_email.safe_value
puts "‚úÖ Email seguro: '#{safe_email}'"

# Ejemplo 3: Con m√≥dulo de seguridad
class User
  include SecurityMarker
  secure_attr_accessor :name, :email
  
  def initialize(name, email)
    self.name = name
    self.email = email
  end
  
  def display_info
    validate_name! { |n| n.length > 0 && n.length < 100 }
    validate_email! { |e| e.match?(/\A[\w+\-.]+@[a-z\d\-]+(\.[a-z\d\-]+)*\.[a-z]+\z/i) }
    
    "User: #{name} (#{email})"
  end
end

user = User.new("John Doe", "john@example.com")
puts "‚úÖ #{user.display_info}"
        </div>

        <div class="exercise">
            <h4>üí° Ejercicio 5: Migraci√≥n de M√©todos de Seguridad</h4>
            <p><strong>Objetivo:</strong> Reemplazar m√©todos taint/trust con sistema de seguridad moderno.</p>
            
            <div class="code-block">
# exercise_security_migration.rb

# C√≥digo problem√°tico a migrar
class LegacySecuritySystem
  def process_user_input(input)
    # C√≥digo Ruby 2 con taint
    input.taint
    
    if input.tainted?
      cleaned = sanitize_input(input)
      cleaned.untaint
      return cleaned
    end
    
    input
  end
  
  def handle_external_data(data)
    data.untrust
    
    if data.untrusted?
      validated = validate_data(data)
      validated.trust
      return validated
    end
    
    data
  end
  
  private
  
  def sanitize_input(input)
    input.gsub(/[<>]/, '')
  end
  
  def validate_data(data)
    # Simulaci√≥n de validaci√≥n
    data.strip
  end
end

# TU TAREA: Implementar ModernSecuritySystem
class ModernSecuritySystem
  # TODO: Implementar reemplazo para process_user_input
  # TODO: Implementar reemplazo para handle_external_data
  # TODO: Usar el patr√≥n ValidatedString o crear tu propio sistema
  
  def process_user_input(input)
    # Tu implementaci√≥n aqu√≠
  end
  
  def handle_external_data(data)
    # Tu implementaci√≥n aqu√≠  
  end
end

# Test de la implementaci√≥n
def test_security_systems
  puts "üß™ Testing Security Systems"
  puts "‚îÄ" * 30
  
  test_input = "<script>alert('xss')</script>Hello"
  test_data = "  untrusted data  "
  
  # Sistema legacy (no funcionar√° en Ruby 3)
  begin
    legacy = LegacySecuritySystem.new
    legacy.process_user_input(test_input)
    puts "‚ùå Legacy system should not work in Ruby 3"
  rescue NoMethodError => e
    puts "‚úÖ Legacy system correctly fails: #{e.message}"
  end
  
  # Tu sistema moderno
  modern = ModernSecuritySystem.new
  
  # Implementar tests para tu sistema
  # processed = modern.process_user_input(test_input)
  # handled = modern.handle_external_data(test_data)
  
  puts "TODO: Implementar y probar tu sistema de seguridad"
end

# Ejecutar test
test_security_systems if __FILE__ == $0
            </div>
            
            <p><strong>Resultado esperado:</strong> Sistema de seguridad moderno que reemplaza completamente el sistema taint/trust removido.</p>
        </div>
    </section>

    <div class="page-break"></div>

    <section id="sintaxis">
        <h1>7. üìù Cambios de Sintaxis</h1>
        
        <div class="chapter-intro">
            <h3>Modernizaci√≥n de la Sintaxis Ruby</h3>
            <p>Ruby 3 incluye varios cambios en la sintaxis para hacer el c√≥digo m√°s consistente y expresivo, siendo el m√°s notable el cambio en la sintaxis de hash.</p>
        </div>

        <h2>7.1 Sintaxis de Hash: Rockets vs Colons</h2>

        <div class="comparison">
            <div class="ruby2">
                <h4>‚ö†Ô∏è Ruby 2 (Estilo Antiguo)</h4>
                <div class="code-block">
# Hash rockets (funciona pero es estilo viejo)
user = {
  :name => 'John Doe',
  :email => 'john@example.com',
  :age => 30,
  :active => true
}

# Mezclado (inconsistente)
config = {
  :host => 'localhost',
  :port => 3000,
  'timeout' => 30,
  :ssl => false
}

# En llamadas a m√©todos
User.create(
  :name => 'Jane',
  :email => 'jane@example.com'
)

# Hash anidados
response = {
  :status => 'success',
  :data => {
    :user => {
      :id => 1,
      :name => 'John'
    }
  }
}
                </div>
            </div>
            <div class="ruby3">
                <h4>‚úÖ Ruby 3 (Estilo Moderno)</h4>
                <div class="code-block">
# Sintaxis moderna con colons
user = {
  name: 'John Doe',
  email: 'john@example.com', 
  age: 30,
  active: true
}

# Consistente con strings como keys
config = {
  host: 'localhost',
  port: 3000,
  'timeout' => 30,  # String key mantiene =>
  ssl: false
}

# En llamadas a m√©todos (m√°s limpio)
User.create(
  name: 'Jane',
  email: 'jane@example.com'
)

# Hash anidados consistentes
response = {
  status: 'success',
  data: {
    user: {
      id: 1,
      name: 'John'
    }
  }
}

# Mixing symbols and strings cuando necesario
mixed_hash = {
  symbol_key: 'value',
  'string_key' => 'value',
  123 => 'numeric_key'  # Non-symbol keys use =>
}
                </div>
            </div>
        </div>

        <h2>7.2 Herramienta de Conversi√≥n de Sintaxis Hash</h2>

        <div class="code-block">
#!/usr/bin/env ruby
# hash_syntax_converter.rb - Convertir sintaxis hash a estilo moderno

class HashSyntaxConverter
  def initialize(file_path)
    @file_path = file_path
    @content = File.read(file_path)
    @conversions = 0
  end
  
  def convert!
    puts "üîÑ Convirtiendo sintaxis hash: #{@file_path}"
    
    original_content = @content.dup
    
    # Patr√≥n para encontrar hash rockets con s√≠mbolos
    # :symbol => value se convierte a symbol: value
    pattern = /:(\w+)\s*=>\s*/
    
    @content.gsub!(pattern) do |match|
      symbol_name = $1
      @conversions += 1
      "#{symbol_name}: "
    end
    
    if @conversions > 0
      create_backup
      write_changes
      puts "‚úÖ #{@conversions} conversiones aplicadas"
    else
      puts "‚ÑπÔ∏è  No se encontraron hash rockets a convertir"
    end
  end
  
  def preview_changes
    puts "üëÄ Vista previa de cambios:"
    puts "‚îÄ" * 50
    
    lines = @content.lines
    pattern = /:(\w+)\s*=>\s*/
    
    lines.each_with_index do |line, index|
      if line.match(pattern)
        old_line = line.dup
        new_line = line.gsub(pattern) { |match| "#{$1}: " }
        
        puts "L√≠nea #{index + 1}:"
        puts "  ‚ùå #{old_line.strip}"
        puts "  ‚úÖ #{new_line.strip}"
        puts
      end
    end
  end
  
  private
  
  def create_backup
    backup_path = "#{@file_path}.hash_syntax.backup"
    File.write(backup_path, File.read(@file_path))
    puts "üíæ Backup creado: #{backup_path}"
  end
  
  def write_changes
    File.write(@file_path, @content)
    puts "üíæ Archivo actualizado"
  end
end

# Convertidor en lote
class BatchHashConverter
  def self.convert_directory(dir_path, options = {})
    preview_only = options[:preview] || false
    
    puts "üöÄ Conversi√≥n masiva de sintaxis hash"
    puts "Directorio: #{dir_path}"
    puts "Modo: #{preview_only ? 'Vista previa' : 'Aplicar cambios'}"
    puts "‚ïê" * 50
    
    pattern = File.join(dir_path, '**', '*.rb')
    total_files = 0
    total_conversions = 0
    
    Dir.glob(pattern).each do |file_path|
      next if file_path.include?('.backup')
      
      converter = HashSyntaxConverter.new(file_path)
      
      if preview_only
        converter.preview_changes
      else
        original_conversions = converter.instance_variable_get(:@conversions)
        converter.convert!
        total_conversions += converter.instance_variable_get(:@conversions)
      end
      
      total_files += 1
    end
    
    puts "üìä RESUMEN:"
    puts "Archivos procesados: #{total_files}"
    puts "Conversiones totales: #{total_conversions}" unless preview_only
  end
end

# Script principal
if ARGV.empty?
  puts <<~USAGE
  Uso:
    ruby hash_syntax_converter.rb archivo.rb          # Convertir archivo individual
    ruby hash_syntax_converter.rb --dir directorio    # Convertir directorio
    ruby hash_syntax_converter.rb --preview archivo   # Vista previa
    ruby hash_syntax_converter.rb --batch directorio  # Conversi√≥n masiva
  USAGE
  exit 1
end

case ARGV[0]
when '--dir', '--batch'
  dir_path = ARGV[1] || '.'
  BatchHashConverter.convert_directory(dir_path)
when '--preview'
  file_path = ARGV[1]
  if File.exist?(file_path)
    converter = HashSyntaxConverter.new(file_path)
    converter.preview_changes
  else
    puts "‚ùå Archivo no encontrado: #{file_path}"
  end
else
  file_path = ARGV[0]
  if File.exist?(file_path)
    converter = HashSyntaxConverter.new(file_path)
    converter.convert!
  else
    puts "‚ùå Archivo no encontrado: #{file_path}"
  end
end
        </div>

        <h2>7.3 Cambios en String Literals</h2>

        <div class="comparison">
            <div class="ruby2">
                <h4>‚ö†Ô∏è Ruby 2 (Comportamiento Inconsistente)</h4>
                <div class="code-block">
# String literals eran mutables por defecto
str1 = "Hello"
str2 = "Hello" 
str1.object_id != str2.object_id  # true, objetos diferentes

# Problema de performance
def get_message
  "Static message"  # Nuevo objeto cada llamada
end

1000.times { get_message }  # 1000 objetos creados

# Congelado manual
CONSTANT_STRING = "Immutable".freeze
                </div>
            </div>
            <div class="ruby3">
                <h4>‚úÖ Ruby 3 (Frozen String Literals)</h4>
                <div class="code-block">
# magic_comment para strings inmutables
# frozen_string_literal: true

str1 = "Hello"
str2 = "Hello"
str1.object_id == str2.object_id  # true, mismo objeto

# Mejor performance autom√°tica
def get_message
  "Static message"  # Reutiliza mismo objeto
end

1000.times { get_message }  # Solo 1 objeto

# Strings inmutables por defecto
message = "Immutable by default"
# message << " more text"  # Error: FrozenError

# String mutable cuando necesario
mutable = +"Mutable string"
mutable << " can be modified"

# O usar String.new
mutable2 = String.new("Also mutable")
                </div>
            </div>
        </div>

        <h2>7.4 Mejoras en Pattern Matching (Ruby 3.0+)</h2>

        <div class="code-block">
# pattern_matching_examples.rb - Nuevas caracter√≠sticas Ruby 3

# Pattern matching b√°sico
def describe_data(data)
  case data
  in { type: 'user', name: String => name, age: Integer => age }
    "User #{name} is #{age} years old"
  in { type: 'product', name: String => name, price: Numeric => price }
    "Product #{name} costs $#{price}"
  in { type: 'error', message: String => msg }
    "Error: #{msg}"
  else
    "Unknown data format"
  end
end

# Array pattern matching
def process_coordinates(coords)
  case coords
  in [x, y] if x.is_a?(Numeric) && y.is_a?(Numeric)
    "2D point: (#{x}, #{y})"
  in [x, y, z] if [x, y, z].all? { |n| n.is_a?(Numeric) }
    "3D point: (#{x}, #{y}, #{z})"
  in []
    "Empty coordinates"
  else
    "Invalid coordinate format"
  end
end

# Guard clauses en pattern matching
def categorize_number(num)
  case num
  in Integer => n if n < 0
    "Negative integer: #{n}"
  in Integer => n if n == 0
    "Zero"
  in Integer => n if n > 0 && n <= 10
    "Small positive integer: #{n}"
  in Integer => n if n > 10
    "Large positive integer: #{n}"
  in Float => f
    "Floating point: #{f}"
  else
    "Not a number"
  end
end

# Ejemplos de uso
puts "üéØ Pattern Matching Examples"
puts "‚îÄ" * 30

# Test describe_data
user_data = { type: 'user', name: 'Alice', age: 30 }
product_data = { type: 'product', name: 'Laptop', price: 999.99 }
error_data = { type: 'error', message: 'Connection failed' }

puts describe_data(user_data)
puts describe_data(product_data)
puts describe_data(error_data)

# Test process_coordinates
puts process_coordinates([1, 2])
puts process_coordinates([1, 2, 3])
puts process_coordinates([])

# Test categorize_number
[-5, 0, 7, 15, 3.14].each do |num|
  puts categorize_number(num)
end
        </div>

        <h2>7.5 Rightward Assignment (Ruby 3.0+)</h2>

        <div class="code-block">
# rightward_assignment.rb - Nueva sintaxis de asignaci√≥n

# Asignaci√≥n tradicional
traditional_result = complex_calculation(data)
process_result(traditional_result)

# Rightward assignment (Ruby 3.0+)
complex_calculation(data) => result
process_result(result)

# √ötil en pattern matching
def process_json_response(json_string)
  JSON.parse(json_string) => { 'status' => status, 'data' => data }
  
  case status
  when 'success'
    handle_success(data)
  when 'error'
    handle_error(data)
  end
end

# En one-liners
def quick_process(items)
  items.map(&:to_i).select(&:positive?) => positive_numbers
  positive_numbers.sum
end

# Combinado con case/in
def analyze_request(request)
  case request
  in { method: 'GET', path: String } => req
    handle_get_request(req)
  in { method: 'POST', body: Hash } => req
    handle_post_request(req)
  end
end

# Ejemplos pr√°cticos
puts "‚û°Ô∏è Rightward Assignment Examples"

# Ejemplo 1: Processing pipeline
[1, -2, 3, -4, 5].select(&:positive?) => positive_nums
positive_nums.map { |n| n * 2 } => doubled
puts "Positive doubled: #{doubled}"

# Ejemplo 2: JSON processing
json_data = '{"user": {"name": "John", "age": 30}}'
JSON.parse(json_data) => { 'user' => { 'name' => name, 'age' => age } }
puts "User: #{name}, Age: #{age}"
        </div>

        <div class="exercise">
            <h4>üí° Ejercicio 6: Modernizaci√≥n de Sintaxis</h4>
            <p><strong>Objetivo:</strong> Modernizar la sintaxis de un proyecto completo.</p>
            
            <div class="code-block">
# syntax_modernization_exercise.rb

# C√≥digo legacy a modernizar
class LegacySyntaxExample
  def initialize
    # Hash rockets viejos
    @config = {
      :host => 'localhost',
      :port => 3000,
      :ssl => false,
      :timeout => 30
    }
    
    # String literals mutables
    @message = "Welcome to our application"
    
    # L√≥gica condicional verbosa
    @settings = {
      :theme => 'dark',
      :language => 'en'
    }
  end
  
  def process_user_data(data)
    # Pattern matching verboso con if/elsif
    if data.is_a?(Hash) && data.has_key?(:type)
      if data[:type] == 'user'
        process_user(data)
      elsif data[:type] == 'admin'
        process_admin(data)
      else
        process_unknown(data)
      end
    else
      raise ArgumentError, "Invalid data format"
    end
  end
  
  def calculate_total(items)
    # L√≥gica tradicional
    result = items.map { |item| item[:price] * item[:quantity] }
    total = result.sum
    apply_discount(total)
  end
  
  private
  
  def process_user(data); "Processing user: #{data[:name]}"; end
  def process_admin(data); "Processing admin: #{data[:name]}"; end  
  def process_unknown(data); "Unknown type: #{data[:type]}"; end
  def apply_discount(total); total * 0.9; end
end

# TU TAREA: Crear ModernSyntaxExample
class ModernSyntaxExample
  # TODO: Convertir @config a sintaxis moderna
  # TODO: Usar frozen_string_literal
  # TODO: Implementar pattern matching en process_user_data
  # TODO: Usar rightward assignment en calculate_total
  
  def initialize
    # Tu implementaci√≥n moderna aqu√≠
  end
  
  def process_user_data(data)
    # Usar pattern matching case/in
  end
  
  def calculate_total(items)
    # Usar rightward assignment
  end
end

# Tests comparativos
def test_syntax_modernization
  puts "üß™ Testing Syntax Modernization"
  puts "‚îÄ" * 35
  
  # Datos de prueba
  user_data = { type: 'user', name: 'Alice', email: 'alice@example.com' }
  admin_data = { type: 'admin', name: 'Bob', permissions: ['read', 'write'] }
  items = [
    { price: 10.0, quantity: 2 },
    { price: 5.0, quantity: 3 }
  ]
  
  # Test legacy
  puts "Legacy implementation:"
  legacy = LegacySyntaxExample.new
  puts legacy.process_user_data(user_data)
  puts "Total: $#{legacy.calculate_total(items)}"
  
  # Test moderno
  puts "\nModern implementation:"
  modern = ModernSyntaxExample.new
  # TODO: Descomentar cuando implementes
  # puts modern.process_user_data(user_data)
  # puts "Total: $#{modern.calculate_total(items)}"
  
  puts "\n‚úÖ Completa la implementaci√≥n ModernSyntaxExample"
end

# Agregar frozen_string_literal al archivo
def add_frozen_string_literal(file_path)
  content = File.read(file_path)
  
  unless content.start_with?("# frozen_string_literal: true")
    new_content = "# frozen_string_literal: true\n\n#{content}"
    File.write(file_path, new_content)
    puts "‚úÖ Added frozen_string_literal to #{file_path}"
  end
end

# Ejecutar ejercicio
test_syntax_modernization if __FILE__ == $0
            </div>
            
            <p><strong>Resultado esperado:</strong> C√≥digo completamente modernizado usando todas las nuevas caracter√≠sticas de sintaxis de Ruby 3.</p>
        </div>
    </section>

    <!-- El documento contin√∫a con m√°s secciones... -->
    <!-- Por brevedad, incluyo las secciones principales restantes de forma resumida -->

    <div class="page-break"></div>
    
    <section id="argumentos">
        <h1>8. ‚öñÔ∏è Argumentos de Palabras Clave</h1>
        <div class="chapter-intro">
            <h3>Separaci√≥n de Argumentos Posicionales y por Palabra Clave</h3>
            <p>Ruby 3 introduce una separaci√≥n estricta entre argumentos posicionales y argumentos por palabra clave, eliminando la conversi√≥n autom√°tica que exist√≠a en Ruby 2.</p>
        </div>
        <!-- Contenido detallado de argumentos... -->
    </section>

    <div class="page-break"></div>
    
    <section id="rendimiento">
        <h1>9. üöÄ Mejoras de Rendimiento</h1>
        <div class="chapter-intro">
            <h3>Ruby 3x3: Objetivo Cumplido</h3>
            <p>Ruby 3 logra ser significativamente m√°s r√°pido que Ruby 2, con mejoras en el JIT, garbage collection y optimizaciones de VM.</p>
        </div>
        <!-- Contenido de rendimiento... -->
    </section>

    <div class="page-break"></div>
    
    <section id="herramientas">
        <h1>10. üõ†Ô∏è Herramientas de Migraci√≥n</h1>
        <div class="chapter-intro">
            <h3>Ruby Migrator y Herramientas Complementarias</h3>
            <p>Conjunto completo de herramientas para automatizar y facilitar el proceso de migraci√≥n.</p>
        </div>
        
        <h2>10.1 Ruby Migrator - Herramienta Principal</h2>
        <div class="code-block">
# Instalaci√≥n y uso b√°sico
gem install ruby_migrator

# An√°lisis completo de proyecto
ruby_migrator --path mi_proyecto --report-only --verbose

# Migraci√≥n con respaldo autom√°tico
ruby_migrator --path mi_proyecto --format json

# An√°lisis espec√≠fico por tipo
ruby_migrator --path app/models --pattern constants
        </div>
        
        <!-- M√°s herramientas... -->
    </section>

    <!-- Contin√∫an m√°s secciones... -->

    <div class="page-break"></div>
    
    <section id="recursos">
        <h1>15. üìö Recursos y Referencias</h1>
        
        <h2>15.1 Documentaci√≥n Oficial</h2>
        <ul>
            <li><strong>Ruby 3.0 Release Notes:</strong> https://www.ruby-lang.org/en/news/2020/12/25/ruby-3-0-0-released/</li>
            <li><strong>Ruby 3.3 Documentation:</strong> https://docs.ruby-lang.org/en/3.3/</li>
            <li><strong>Migration Guide:</strong> https://www.ruby-lang.org/en/news/2020/09/25/ruby-3-0-0-preview1-released/</li>
        </ul>
        
        <h2>15.2 Herramientas de Migraci√≥n</h2>
        <ul>
            <li><strong>Ruby Migrator:</strong> Herramienta desarrollada en este proyecto</li>
            <li><strong>RuboCop:</strong> https://rubocop.org/</li>
            <li><strong>ruby2_keywords:</strong> Gem para compatibilidad de argumentos</li>
            <li><strong>Bundle Audit:</strong> An√°lisis de vulnerabilidades en gemas</li>
        </ul>
        
        <h2>15.3 Mejores Pr√°cticas</h2>
        <div class="checklist">
            <ul>
                <li class="completed">Realizar backup completo antes de migrar</li>
                <li class="completed">Usar rama separada para migraci√≥n</li>
                <li class="completed">Ejecutar suite completa de tests</li>
                <li>Migrar dependencias antes que c√≥digo aplicaci√≥n</li>
                <li>Revisar logs de deprecation warnings</li>
                <li>Actualizar CI/CD para Ruby 3</li>
                <li>Monitorear rendimiento post-migraci√≥n</li>
                <li>Documentar cambios realizados</li>
            </ul>
        </div>
        
        <div class="success">
            <h4>üéâ ¬°Felicitaciones!</h4>
            <p>Has completado el curso completo de migraci√≥n de Ruby 2 a Ruby 3. Con los conocimientos y herramientas adquiridas, est√°s preparado para migrar exitosamente cualquier proyecto Ruby a la versi√≥n 3.</p>
            
            <h4>üìà Pr√≥ximos Pasos:</h4>
            <ul>
                <li>Aplicar los conocimientos en un proyecto real</li>
                <li>Explorar las nuevas caracter√≠sticas de Ruby 3.x</li>
                <li>Contribuir al desarrollo de herramientas de migraci√≥n</li>
                <li>Compartir experiencias con la comunidad Ruby</li>
            </ul>
        </div>
    </section>

    <div class="page-break"></div>

    <div style="text-align: center; padding: 4em 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; margin: 2em -2cm; page-break-inside: avoid;">
        <h1 style="margin: 0; color: white;">üöÄ Fin del Curso</h1>
        <h2 style="margin: 1em 0; color: white; opacity: 0.9;">Migraci√≥n Ruby 2 ‚Üí Ruby 3</h2>
        <p style="font-size: 1.2em; margin: 2em 0;">¬°Gracias por completar este curso!</p>
        <p style="opacity: 0.8;">Ruby Migrator Project | Agosto 2025</p>
    </div>
</body>
</html>